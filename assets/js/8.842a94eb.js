(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{175:function(e,t,_){"use strict";_.r(t);var s=_(0),n=Object(s.a)({},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),_("p",[e._v("WebSocket 是一种网络通信协议。RFC6455 定义了它的通信标准。\nWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。")]),e._v(" "),e._m(2),e._v(" "),_("p",[e._v("前端的websocket\n服务端的websocket")]),e._v(" "),_("p",[e._v("http与websocket")]),e._v(" "),_("p",[e._v('webSocket知识点\n1.webSocket是一个持久化的协议；建立在TCP协议之上；协议标识符是 ws,如果加密，则为 wss(ws://example.com:80/some/path)\n2.websocket握手请求比http握手请求多了（浏览器 -> 服务器）：\nUpgrade: websocket, Connection: Upgrade 这两个字段（主要是告诉服务器，此请求为websocket请求）；\nSec-webSocket-key 是用于握手协议的密钥，是base64编码的16字节随机字符串。\n3.服务端的webSocket回应（服务端 -> 浏览器）：\nUpgrade: websocket, Connection: Upgrade 这两个字段（告诉浏览器，开始使用webSocket协议）；\nSec-webSocket-Accept 是服务在在浏览器提供的Sec-webSocket-key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求。\n4.使用方式：\nvar ws = new WebSocket("ws://localhost:9998/echo");\nws.onopen = function() { ws.send("发送数据"); };\nws.onmessage = function (evt) {var received_msg = evt.data; };\nws.onclose = function() { // 关闭 websocket };\nws.onerror = function() { // websocket 连接发生错误 };\niOS应用程序生命周期(前后台切换,应用的各种状态)详解\n1.Not running 未运行\n程序没启动\n2.Inactive 未激活\n程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态\n3.Active 激活\n程序在前台运行而且接收到了事件。这也是前台的一个正常的模式\n4.Backgroud 后台\n5.Suspended 挂起\nimage')]),e._v(" "),_("p",[e._v("socketjs")]),e._v(" "),e._m(3),e._v(" "),_("p",[e._v("websocket是什么？\nwebSocket是HTML5开始提供的一种在单个TCP连接上进行去全双工通讯的协议。旨在浏览器与服务器之间建立一种长期、双向的通讯。\n最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。")]),e._v(" "),e._m(4),e._v(" "),_("p",[e._v("解决的什么问题？\nHTTP协议的一个缺陷：通讯只能由客户端发起。在websocket出现，都是通过轮询机制（或者 HTTP 连接始终打开）实现客户端和浏览器的数据同步。")]),e._v(" "),e._m(5),e._v(" "),e._m(6),e._v(" "),e._m(7),e._v(" "),_("p",[e._v("方法")]),e._v(" "),_("p",[e._v("WebSocket.send()")]),e._v(" "),_("p",[e._v("事件\nonopen // 连接成功的回调")]),e._v(" "),_("p",[e._v("onmessage // 用于指定收到服务器数据后的回调函数。")]),e._v(" "),_("p",[e._v("onclose // 了解关闭的回调")]),e._v(" "),_("p",[e._v("onerror // 报错时的回调函数")]),e._v(" "),_("p",[e._v("webSocket.send() // 客户端发数据\n兼容性？")]),e._v(" "),_("p",[e._v("案例\nSOCKET.IO node\nSockJS java 服务端也要设置")]),e._v(" "),_("p",[e._v("https://www.jianshu.com/p/4ef5004a1c81")]),e._v(" "),_("p",[e._v("https://blog.csdn.net/dadiyang/article/details/83715569")]),e._v(" "),_("p",[e._v("https://blog.csdn.net/ligang2585116/article/details/47277917")]),e._v(" "),_("p",[e._v("https://segmentfault.com/a/1190000013588737")]),e._v(" "),_("p",[e._v("http://www.ruanyifeng.com/blog/2017/05/websocket.html\nwebsocketd一款非常特别的 "),_("a",{attrs:{href:"http://websocketd.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebSocket"),_("OutboundLink")],1),e._v(" 服务器\n控制台\nvar ws = new WebSocket('ws://localhost:8080/');")]),e._v(" "),_("p",[e._v("ws.onmessage = function(event) {\nws.send('hello word!')\nconsole.log(event.data);\n};")]),e._v(" "),_("p",[e._v("常量\t值\t状态\nWebSocket.CONNECTION\t0\t正在握手请求中，还未完成连接\nWebSocket.OPEN\t1\t连接已打开\nWebSocket.CLOSING\t2\t连接正在关闭\nWebSocket.CLOSED\t3\t连接已关闭")]),e._v(" "),_("p",[e._v("SockJS的一大好处在于提供了浏览器兼容性。优先使用原生WebSocket，如果在不支持websocket的浏览器中，会自动降为轮询的方式。")]),e._v(" "),_("p",[e._v("服务器与客户端 数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）")]),e._v(" "),_("p",[e._v("https://blog.csdn.net/maomaolaoshi/article/details/82593106 // 请求头中添加参数的几种方式")]),e._v(" "),_("p",[e._v("https://segmentfault.com/q/1010000012939637\nhttps://www.jb51.net/article/146452.html")]),e._v(" "),_("p",[e._v("https://www.cnblogs.com/Vince-blogs/p/8087233.html")]),e._v(" "),_("p",[e._v("https://blog.csdn.net/qq_32331073/article/details/82665419")]),e._v(" "),_("p",[e._v("es5 实现 es6 this控制 三大框架 create-react-app")]),e._v(" "),_("p",[e._v("class 反射 代理  元编程 node - 加分项")]),e._v(" "),_("p",[e._v("微服务")]),e._v(" "),_("p",[e._v("https://blog.csdn.net/dadiyang/article/details/83715569 sockJS")]),e._v(" "),e._m(8),e._v(" "),e._m(9),e._v(" "),e._m(10),e._v(" "),e._m(11),e._v(" "),e._m(12),e._v(" "),_("p",[e._v('是因为在http协议做不到服务器主动向客户端发送数据。\n在这\nHTTP协议的一个缺陷：通讯只能由客户端发起。在websocket出现，都是通过轮询机制（或者 HTTP 连接始终打开）实现客户端和浏览器的数据同步。\n这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。')]),e._v(" "),_("p",[e._v("轮询的效率低，非常浪费资源（因为必须不停连接，或者HTTP连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket就是这样发明的")]),e._v(" "),e._m(13),e._v(" "),_("p",[e._v("但是Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。")]),e._v(" "),_("p",[e._v("同时由客户主动询问，转换为服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。），没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的客服（Handler）了")]),e._v(" "),e._m(14),e._v(" "),_("p",[e._v("API\nWebSocket")]),e._v(" "),e._m(15),e._v(" "),_("p",[e._v("方法\n// 客户端向服务端发送数据\nWebSocket.send()")]),e._v(" "),_("p",[e._v("事件\nonopen // 连接成功的回调。")]),e._v(" "),_("p",[e._v("onmessage // 用于指定收到服务器数据后的回调函数。")]),e._v(" "),_("p",[e._v("onclose // 了解关闭的回调。")]),e._v(" "),_("p",[e._v("onerror // 报错时的回调函数。")]),e._v(" "),_("p",[e._v("webSocket.send() // 客户端发数据。")]),e._v(" "),e._m(16),e._v(" "),_("p",[e._v("使用轮询或长连接的方式实现伪websocket的通信")]),e._v(" "),_("p",[e._v("使用flash或其他方法实现一个websocket客户端 ：https://segmentfault.com/q/1010000005000671/a-1020000005003936")]),e._v(" "),_("p",[e._v("https://blog.csdn.net/u011925826/article/details/17532465")]),e._v(" "),e._m(17)])},[function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket","aria-hidden":"true"}},[this._v("#")]),this._v(" websocket")])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("ol",[t("li",[this._v("websocket是啥？")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[t("ol",{attrs:{start:"2"}},[t("li",[this._v("为什么需要websocket？")])])]),this._v(" "),t("li",[this._v("解决的问题？")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ol",[t("li",[this._v("是一个浏览器Javascript库，提供了一个类似webSocket的对象。")]),this._v(" "),t("li",[this._v("提供了一个连续跨浏览器的JavascriptAPI，在浏览器和web服务起之间创建了一个低延迟、全双工、跨域的通讯通道。")]),this._v(" "),t("li",[this._v("在底层sockjs首先尝试使用本地websocket，如果失败了，他可以使用各种浏览器特定的传输协议，并通过类似websocket的抽象方式呈现")]),this._v(" "),t("li",[this._v("sockjs在适用所有现代浏览器和不支持websocket协议环境")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("ul",[t("li",[this._v("TCP 传输控制协议。")]),this._v(" "),t("li",[this._v("全双工: 全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。")])])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("缺点\n"),_("ul",[_("li",[e._v("频繁的请求（或者 HTTP 连接始终打开）来保证客户端与服务端的同步。"),_("code",[e._v("低效浪费资源")])]),e._v(" "),_("li",[e._v("HTTP 协议无法实现服务器主动向客户端发起消息。\n"),_("ul",[_("li",[e._v("通讯只能由客户端发起")]),e._v(" "),_("li",[e._v("服务端对请求作出应答")]),e._v(" "),_("li",[e._v("协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n只能由客户端发起服务")])])])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("好处\n性能开销小，双向通讯。\n没有同源限制，客户端可以与任意的服务器。\n协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。\n怎样运作的？\n怎样使用？\nAPI\nWebSocket"),t("code",[this._v("只读属性")])])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("Socket.readyState\n"),_("ul",[_("li",[e._v("CONNECTING"),_("code",[e._v("0")]),e._v(" 尚未建立连接。")]),e._v(" "),_("li",[e._v("OPEN"),_("code",[e._v("1")]),e._v(" 连接已建立，可以进行通信。")]),e._v(" "),_("li",[e._v("CLOSING"),_("code",[e._v("2")]),e._v(" 连接正在进行关闭。")]),e._v(" "),_("li",[e._v("CLOSED"),_("code",[e._v("3")]),e._v(" 了解已关闭或连接不能打开。")])])]),e._v(" "),_("li",[e._v("Socket.bufferedAmount"),_("code",[e._v("只读属性")]),e._v(" "),_("ul",[_("li",[e._v("当客户端向服务端发送大量数据时，浏览器会先将数据缓存到浏览器的发送队列里，然后逐段地向服务器发送，bufferedAmount这个特性就是告诉客户端现在队列里还有多少已经缓存了但没发送的数据。")]),e._v(" "),_("li")])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h1",{attrs:{id:"websocket-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket-2","aria-hidden":"true"}},[this._v("#")]),this._v(" WebSocket")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"_1-websocket是什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-websocket是什么？","aria-hidden":"true"}},[this._v("#")]),this._v(" 1. WebSocket是什么？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("p",[this._v("webSocket是一种网络通信协议，很多高级功能都需要它。\n最大特点就是，"),t("code",[this._v("服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。")]),this._v("\nwebSocket是HTML5开始提供的一种在单个TCP连接上进行去全双工通讯的协议。在浏览器与服务器之间建立一种长期、双向的通讯。")])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("TCP 传输控制协议。")]),e._v(" "),_("li",[e._v("全双工: 全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。")]),e._v(" "),_("li",[e._v("特点\n"),_("ul",[_("li",[e._v("没有同源限制，客户端可以与任意服务器通信。")]),e._v(" "),_("li",[e._v("可以发送文本，也可以发送二进制数据。")]),e._v(" "),_("li",[e._v("与HTTP协议有着良好的兼容性，默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器。")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"为什么会出现websocket？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么会出现websocket？","aria-hidden":"true"}},[this._v("#")]),this._v(" 为什么会出现WebSocket？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"_2-websocket解决了什么问题？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-websocket解决了什么问题？","aria-hidden":"true"}},[this._v("#")]),this._v(" 2. WebSocket解决了什么问题？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"_3-websocket怎样使用？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-websocket怎样使用？","aria-hidden":"true"}},[this._v("#")]),this._v(" 3. WebSocket怎样使用？")])},function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ul",[_("li",[e._v("Socket.readyState"),_("code",[e._v("只读属性")]),e._v(" "),_("ul",[_("li",[e._v("CONNECTING"),_("code",[e._v("0")]),e._v(" 尚未建立连接。")]),e._v(" "),_("li",[e._v("OPEN"),_("code",[e._v("1")]),e._v(" 连接已建立，可以进行通信。")]),e._v(" "),_("li",[e._v("CLOSING"),_("code",[e._v("2")]),e._v(" 连接正在进行关闭。")]),e._v(" "),_("li",[e._v("CLOSED"),_("code",[e._v("3")]),e._v(" 了解已关闭或连接不能打开。")])])]),e._v(" "),_("li",[e._v("Socket.bufferedAmount"),_("code",[e._v("只读属性")]),e._v(" "),_("ul",[_("li",[e._v("当客户端向服务端发送大量数据时，浏览器会先将数据缓存到浏览器的发送队列里，然后逐段地向服务器发送，bufferedAmount这个特性就是告诉客户端现在队列里还有多少已经缓存了但没发送的数据。")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"_4-websocket兼容性？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-websocket兼容性？","aria-hidden":"true"}},[this._v("#")]),this._v(" 4. WebSocket兼容性？")])},function(){var e=this.$createElement,t=this._self._c||e;return t("h2",{attrs:{id:"_1"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1","aria-hidden":"true"}},[this._v("#")]),this._v(" 1.")])}],!1,null,null,null);n.options.__file="websocket.md";t.default=n.exports}}]);